CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

# Set mfmg version
SET(MFMG_VERSION_MAJOR 0)
SET(MFMG_VERSION_MINOR 1)
SET(MFMG_VERSION_PATCH 0)
SET(MFMG_VERSION
  ${MFMG_VERSION_MAJOR}.${MFMG_VERSION_MINOR}.${MFMG_VERSION_PATCH})
MESSAGE("-- mfmg version: ${MFMG_VERSION}")

PROJECT(mfmg LANGUAGES CXX VERSION ${MFMG_VERSION})

SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
INCLUDE(SetupCUDA)
INCLUDE(SetupTPLs)
INCLUDE(SetupMFMG)
INCLUDE(SetupCache)

# By default build a static library because CUDA does not work with a shared
# library
OPTION(BUILD_SHARED_LIBS "Build a shared library" OFF)

INITIALIZE_CACHE()

IF(${MFMG_ENABLE_CUDA})
  IF (${BUILD_SHARED_LIBS})
    MESSAGE(SEND_ERROR "CUDA build does not support shared library")
  ENDIF()
  # ENABLE_LANGUAGE cannot be in a function and it has to be called in the
  # highest directory so we cannot encapsulate it
  ENABLE_LANGUAGE(CUDA)
  SET_CUDA_LIBRARIES()
  IF (${MFMG_ENABLE_CUDA_MPI})
    ADD_DEFINITIONS(-DMFMG_WITH_CUDA_MPI)
  ENDIF()
ENDIF()

IF(${MFMG_ENABLE_STACKTRACE})
  FIND_PACKAGE(Backtrace)
  IF(${Backtrace_FOUND})
    ADD_DEFINITIONS(-DMFMG_WITH_STACKTRACE)
  ELSE()
    MESSAGE(SEND_ERROR "Did not find Backtrace")
  ENDIF()
ENDIF()

IF(${MFMG_ENABLE_COVERAGE})
  INCLUDE(CodeCoverage)
ENDIF()

ENABLE_TESTING()
INCLUDE(CTest)

IF(${MFMG_ENABLE_TESTS})
  ADD_SUBDIRECTORY(tests)
ENDIf()

# Check code style using clang-format
IF(${MFMG_ENABLE_CLANGFORMAT})
  INCLUDE(CodeFormat)
ENDIF()

IF(${MFMG_ENABLE_CLANGTIDY})
  INCLUDE(CodeTidy)
ENDIF()

IF(${MFMG_ENABLE_DOCUMENTATION})
  ADD_SUBDIRECTORY(doc)
ENDIF()

INCLUDE_DIRECTORIES(include)
FILE(GLOB MFMG_HEADERS "include/*.hpp" "include/*.cuh")

ADD_SUBDIRECTORY(source)

ADD_LIBRARY(mfmg ${MFMG_SOURCES})
TARGET_INCLUDE_DIRECTORIES(mfmg SYSTEM PUBLIC ${MPI_CXX_INCLUDE_PATH})
TARGET_LINK_LIBRARIES(mfmg PUBLIC ${MPI_CXX_LIBRARIES})
TARGET_INCLUDE_DIRECTORIES(mfmg SYSTEM PUBLIC ${Boost_INCLUDE_DIRS})
TARGET_INCLUDE_DIRECTORIES(mfmg SYSTEM PUBLIC ${DEAL_II_INCLUDE_DIRS})
TARGET_LINK_LIBRARIES(mfmg PUBLIC ${DEAL_II_LIBRARIES})
TARGET_INCLUDE_DIRECTORIES(mfmg SYSTEM PUBLIC ${LAPACKE_INCLUDE_DIR})
TARGET_LINK_LIBRARIES(mfmg PUBLIC ${LAPACKE_LIBRARY})
TARGET_LINK_LIBRARIES(mfmg PUBLIC ${MFMG_CUDA_LIBRARIES})
TARGET_INCLUDE_DIRECTORIES(mfmg PUBLIC ${AMGX_INCLUDE_DIR})
TARGET_LINK_LIBRARIES(mfmg PUBLIC ${AMGX_LIBRARY})
TARGET_COMPILE_DEFINITIONS(mfmg PRIVATE ${CLANG_TIDY_DEFINITIONS})

IF(${Backtrace_FOUND})
  TARGET_LINK_LIBRARIES(mfmg PUBLIC ${CMAKE_DL_LIBS})
  IF ("${Backtrace_LIBRARIES}" STREQUAL "")
    TARGET_LINK_LIBRARIES(mfmg PUBLIC "backtrace")
  ENDIF()
ENDIF()


# Ideally we would like to always set the target properties for C++ and only
# append the property for CUDA if necessary. However, this does not work because
# cmake then thinks that the CUDA standard is 11;11.
IF(${MFMG_ENABLE_CUDA})
  SET_TARGET_PROPERTIES(mfmg PROPERTIES
    CUDA_SEPARABLE_COMPILATION ON
    CUDA_STANDARD 14
    CUDA_STANDARD_REQUIRED ON
    CXX_STANDARD 14
    CXX_STANDARD_REQUIRED ON
    # Don't use -std=gnu++14
    CXX_EXTENSIONS OFF
    VERSION ${MFMG_VERSION}
    PUBLIC_HEADER "${MFMG_HEADERS}"
    )
ELSE()
  SET_TARGET_PROPERTIES(mfmg PROPERTIES
    CXX_STANDARD 14
    CXX_STANDARD_REQUIRED ON
    # Don't use -std=gnu++14
    CXX_EXTENSIONS OFF
    VERSION ${MFMG_VERSION}
    PUBLIC_HEADER "${MFMG_HEADERS}"
    )
ENDIF()

# Install the library
INSTALL(TARGETS mfmg
  ARCHIVE DESTINATION ${CMAKE_INSTALL_PREFIX}/lib
  LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib
  PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_PREFIX}/include)

# Create the config file
CONFIGURE_FILE(cmake/mfmgConfig.cmake.in
  ${CMAKE_BINARY_DIR}/cmake/mfmgConfig.cmake
  @ONLY
  )

# Install the config file
INSTALL(FILES ${CMAKE_BINARY_DIR}/cmake/mfmgConfig.cmake
  DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/cmake/mfmg
  )
